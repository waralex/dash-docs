}
app$callback(
function(sd1 = sd1, sd2 = sd2, sd3 = sd3) {
riris(selectDataToKey(sd1))
riris(selectDataToKey(sd2))
riris(selectDataToKey(sd3))
dat2fig(riris(), x = "Sepal.Length", y = "Sepal.Width")
}, output("g1", "figure")
)
app$callback(
function(sd1 = sd1, sd2 = sd2, sd3 = sd3) {
riris(selectDataToKey(sd1))
riris(selectDataToKey(sd2))
riris(selectDataToKey(sd3))
dat2fig(riris(), x = "Sepal.Width", y = "Petal.Length")
}, output("g2", "figure")
)
app$callback(
function(sd1 = sd1, sd2 = sd2, sd3 = sd3) {
riris(selectDataToKey(sd1))
riris(selectDataToKey(sd2))
riris(selectDataToKey(sd3))
dat2fig(riris(), x = "Petal.Length", y = "Petal.Width")
}, output("g3", "figure")
)
#
# app$layout_set(htmlDiv(list(
#   htmlDiv(
#     dccGraph(
#       id='g1',
#       config=list(displayModeBar = FALSE)
#     ), className='four columns'
#   ),
#   htmlDiv(
#     dccGraph(
#       id='g2',
#       config=list(displayModeBar = FALSE)
#     ), className='four columns'),
#   htmlDiv(
#     dccGraph(
#       id='g3',
#       config=list(displayModeBar = FALSE)
#     ), className='four columns')
#   ), className='row')
# )
# def highlight(x, y):
#   def callback(*selectedDatas):
#   selectedpoints = df.index
# for i, selected_data in enumerate(selectedDatas):
#   if selected_data is not None:
#   selected_index = [
#     p['customdata'] for p in selected_data['points']
#     ]
# if len(selected_index) > 0:
#   selectedpoints = np.intersect1d(
#     selectedpoints, selected_index)
#
#
# # set which points are selected with the `selectedpoints` property
# # and style those points with the `selected` and `unselected`
# # attribute. see
# # https://medium.com/@plotlygraphs/notes-from-the-latest-plotly-js-release-b035a5b43e21
# # for an explanation
#
# figure = {
#   'data': [
#     {
#       'x': df[x],
#       'y': df[y],
#       'text': df.index,
#       'textposition': 'top',
#       'selectedpoints': selectedpoints,
#       'customdata': df.index,
#       'type': 'scatter',
#       'mode': 'markers+text',
#       'marker': {
#         'color': 'rgba(0, 116, 217, 0.7)',
#         'size': 12,
#         'line': {
#           'color': 'rgb(0, 116, 217)',
#           'width': 0.5
#         }
#       },
#       'textfont': {
#         'color': 'rgba(30, 30, 30, 1)'
#       },
#       'unselected': {
#         'marker': {
#           'opacity': 0.3,
#         },
#         'textfont': {
#           # make text transparent when not selected
#           'color': 'rgba(0, 0, 0, 0)'
#         }
#       }
#     },
#     ],
#   'layout': {
#     'clickmode': 'event+select',
#     'margin': {'l': 15, 'r': 0, 'b': 15, 't': 5},
#     'dragmode': 'select',
#     'hovermode': 'closest',
#     'showlegend': False
#   }
# }
#
# # Display a rectangle to highlight the previously selected region
# shape = {
#   'type': 'rect',
#   'line': {
#     'width': 1,
#     'dash': 'dot',
#     'color': 'darkgrey'
#   }
# }
# if selectedDatas[0] and selectedDatas[0]['range']:
#   figure['layout']['shapes'] = [dict({
#     'x0': selectedDatas[0]['range']['x'][0],
#     'x1': selectedDatas[0]['range']['x'][1],
#     'y0': selectedDatas[0]['range']['y'][0],
#     'y1': selectedDatas[0]['range']['y'][1]
#   }, **shape)]
# else:
#   figure['layout']['shapes'] = [dict({
#     'type': 'rect',
#     'x0': np.min(df[x]),
#     'x1': np.max(df[x]),
#     'y0': np.min(df[y]),
#     'y1': np.max(df[y])
#   }, **shape)]
#
# return figure
#
# return callback
#
#
#
# # app.callback is a decorator which means that it takes a function
# # as its argument.
# # highlight is a function "generator": it's a function that returns function
# app.callback(
#   Output('g1', 'figure'),
#   [Input('g1', 'selectedData'),
#    Input('g2', 'selectedData'),
#    Input('g3', 'selectedData')]
# )(highlight('Column 0', 'Column 1'))
#
# app.callback(
#   Output('g2', 'figure'),
#   [Input('g2', 'selectedData'),
#    Input('g1', 'selectedData'),
#    Input('g3', 'selectedData')]
# )(highlight('Column 2', 'Column 3'))
#
# app.callback(
#   Output('g3', 'figure'),
#   [Input('g3', 'selectedData'),
#    Input('g1', 'selectedData'),
#    Input('g2', 'selectedData')]
# )(highlight('Column 4', 'Column 5'))
app$run_heroku()
library(dashR)
library(dashCoreComponents)
library(dashHtmlComponents)
app <- Dash$new()
set.seed(0)
df <- data.frame(replicate(10,sample(0:30,6,rep=TRUE)))
# pd.DataFrame({
# 'Column {}'.format(i): np.random.rand(30) + i*10
# for i in range(6)})
app$layout_set(htmlDiv(list(
htmlDiv(
dccGraph(
id='g1',
config=list(displayModeBar = FALSE)
), className='four columns'
),
htmlDiv(
dccGraph(
id='g2',
config=list(displayModeBar = FALSE)
), className='four columns'),
htmlDiv(
dccGraph(
id='g3',
config=list(displayModeBar = FALSE)
), className='four columns')
), className='row')
)
highlight <- function(x, y){
def callback(*selectedDatas):
selectedpoints = df.index
for i, selected_data in enumerate(selectedDatas):
if selected_data is not None:
selected_index = [
p['customdata'] for p in selected_data['points']
]
if len(selected_index) > 0:
selectedpoints = np.intersect1d(
selectedpoints, selected_index)
# set which points are selected with the `selectedpoints` property
# and style those points with the `selected` and `unselected`
# attribute. see
# https://medium.com/@plotlygraphs/notes-from-the-latest-plotly-js-release-b035a5b43e21
# for an explanation
figure = list(
data = list(
list(
x = df$x,
y = df$y,
text = df.index,
textposition = 'top',
selectedpoints = selectedpoints,
customdata = df.index,
type = 'scatter',
mode = 'markers+text',
marker = list(
color = 'rgba(0, 116, 217, 0.7)',
size = 12,
line = list(
color = 'rgb(0, 116, 217)',
width = 0.5
)
),
textfont = list(
color = 'rgba(30, 30, 30, 1)'
),
unselected = list(
marker = list(
opacity = 0.3,
),
textfont = list(
# make text transparent when not selected
color = 'rgba(0, 0, 0, 0)'
)
)
},
),
layout = list(
clickmode = 'event+select',
margin = list(l = 15, r = 0, b = 15, t = 5),
dragmode = 'select',
hovermode = 'closest',
showlegend = FALSE
)
)
# Display a rectangle to highlight the previously selected region
shape = list(
type = 'rect',
line = list(
width = 1,
dash = 'dot',
color = 'darkgrey'
)
)
figure = list(
data = list(
list(
x = c(1, 2, 3, 4),
y = c(4, 1, 3, 5),
text = c('a', 'b', 'c', 'd'),
customdata = c('c.a', 'c.b', 'c.c', 'c.d'),
name = 'Trace 1',
mode = 'markers',
marker = list(size = 12)
),
list(
x = c(1, 2, 3, 4),
y = c(9, 4, 1, 4),
text = c('w', 'x', 'y', 'z'),
customdata = c('c.w', 'c.x', 'c.y', 'c.z'),
name = 'Trace 2',
mode = 'markers',
marker = list(size = 12)
)
)
)
# if selectedDatas[0] and selectedDatas[0]['range']:
#   figure$layout$shapes = [dict({
#     'x0': selectedDatas[0]['range']['x'][0],
#     'x1': selectedDatas[0]['range']['x'][1],
#     'y0': selectedDatas[0]['range']['y'][0],
#     'y1': selectedDatas[0]['range']['y'][1]
#   }, **shape)]
# else:
#   figure['layout']['shapes'] = [dict({
#     'type': 'rect',
#     'x0': np.min(df[x]),
#     'x1': np.max(df[x]),
#     'y0': np.min(df[y]),
#     'y1': np.max(df[y])
#   }, **shape)]
#
return(figure)
return(callback)
}
# def highlight(x, y):
#   def callback(*selectedDatas):
#   selectedpoints = df.index
# for i, selected_data in enumerate(selectedDatas):
#   if selected_data is not None:
#   selected_index = [
#     p['customdata'] for p in selected_data['points']
#     ]
# if len(selected_index) > 0:
#   selectedpoints = np.intersect1d(
#     selectedpoints, selected_index)
#
#
# # set which points are selected with the `selectedpoints` property
# # and style those points with the `selected` and `unselected`
# # attribute. see
# # https://medium.com/@plotlygraphs/notes-from-the-latest-plotly-js-release-b035a5b43e21
# # for an explanation
#
# figure = {
#   'data': [
#     {
#       'x': df[x],
#       'y': df[y],
#       'text': df.index,
#       'textposition': 'top',
#       'selectedpoints': selectedpoints,
#       'customdata': df.index,
#       'type': 'scatter',
#       'mode': 'markers+text',
#       'marker': {
#         'color': 'rgba(0, 116, 217, 0.7)',
#         'size': 12,
#         'line': {
#           'color': 'rgb(0, 116, 217)',
#           'width': 0.5
#         }
#       },
#       'textfont': {
#         'color': 'rgba(30, 30, 30, 1)'
#       },
#       'unselected': {
#         'marker': {
#           'opacity': 0.3,
#         },
#         'textfont': {
#           # make text transparent when not selected
#           'color': 'rgba(0, 0, 0, 0)'
#         }
#       }
#     },
#     ],
#   'layout': {
#     'clickmode': 'event+select',
#     'margin': {'l': 15, 'r': 0, 'b': 15, 't': 5},
#     'dragmode': 'select',
#     'hovermode': 'closest',
#     'showlegend': False
#   }
# }
#
# # Display a rectangle to highlight the previously selected region
# shape = {
#   'type': 'rect',
#   'line': {
#     'width': 1,
#     'dash': 'dot',
#     'color': 'darkgrey'
#   }
# }
# if selectedDatas[0] and selectedDatas[0]['range']:
#   figure['layout']['shapes'] = [dict({
#     'x0': selectedDatas[0]['range']['x'][0],
#     'x1': selectedDatas[0]['range']['x'][1],
#     'y0': selectedDatas[0]['range']['y'][0],
#     'y1': selectedDatas[0]['range']['y'][1]
#   }, **shape)]
# else:
#   figure['layout']['shapes'] = [dict({
#     'type': 'rect',
#     'x0': np.min(df[x]),
#     'x1': np.max(df[x]),
#     'y0': np.min(df[y]),
#     'y1': np.max(df[y])
#   }, **shape)]
#
# return figure
#
# return callback
#
#
#
# # app.callback is a decorator which means that it takes a function
# # as its argument.
# # highlight is a function "generator": it's a function that returns function
# app.callback(
#   Output('g1', 'figure'),
#   [Input('g1', 'selectedData'),
#    Input('g2', 'selectedData'),
#    Input('g3', 'selectedData')]
# )(highlight('Column 0', 'Column 1'))
#
# app.callback(
#   Output('g2', 'figure'),
#   [Input('g2', 'selectedData'),
#    Input('g1', 'selectedData'),
#    Input('g3', 'selectedData')]
# )(highlight('Column 2', 'Column 3'))
#
# app.callback(
#   Output('g3', 'figure'),
#   [Input('g3', 'selectedData'),
#    Input('g1', 'selectedData'),
#    Input('g2', 'selectedData')]
# )(highlight('Column 4', 'Column 5'))
app$run_heroku()
#Step 1: Create a text file
# Install
#install.packages("tm")  # for text mining
#install.packages("SnowballC") # for text stemming
#install.packages("wordcloud") # word-cloud generator
#install.packages("RColorBrewer") # color palettes
# Load
library("tm")
library("SnowballC")
library("wordcloud")
library("RColorBrewer")
cname <- file.path("~", "Desktop", "text_azz")
#cname <- file.path("~", "Desktop", "TEXT_R", "Biosensor.txt")
#corp<-Corpus(DirSource(cname))
docs<-Corpus(DirSource(cname))
#Inspect the content of the document
inspect(docs)
#dir(cname)
#summary(docs)
#Text transformation using tm_map() function
#to replace, for example, special characters from the text.
toSpace <- content_transformer(function (x , pattern ) gsub(pattern, " ", x))
docs <- tm_map(docs, toSpace, "/")
docs <- tm_map(docs, toSpace, "@")
docs <- tm_map(docs, toSpace, "\\|")
# Convert the text to lower case
docs <- tm_map(docs, content_transformer(tolower))
# Remove numbers
docs <- tm_map(docs, removeNumbers)
# Remove english common stopwords
docs <- tm_map(docs, removeWords, stopwords("english"))
# Remove your own stop word
# specify your stopwords as a character vector
docs <- tm_map(docs, removeWords, c("blabla1", "blabla2"))
# Remove punctuations
docs <- tm_map(docs, removePunctuation)
# Eliminate extra white spaces
docs <- tm_map(docs, stripWhitespace)
# Text stemming
# docs <- tm_map(docs, stemDocument)
inspect(docs)
dtm <- TermDocumentMatrix(docs)
typeof(dtm)
m <- as.matrix(dtm)
#as.matrix returns all values of a Raster* object as a matrix.
v <- sort(rowSums(m),decreasing=TRUE)
d <- data.frame(word = names(v),freq=v)
head(d, 15)
set.seed(1234)
wordcloud(words = d$word, freq = d$freq, min.freq = 1,
max.words=300, random.order=FALSE, rot.per=0.35,
colors=brewer.pal(15, "Dark2"))
#to find words that occur at least ten times :
findFreqTerms(dtm, lowfreq = 10)
#to find association between frequent terms
findAssocs(dtm, terms = "cell", corlimit = 0.5)
barplot(d[1:20,]$freq, las = 2, names.arg = d[1:20,]$word,
col ="lightblue", main ="Most frequent words",
ylab = "Word frequencies")
install.packages("tm")  # for text mining
install.packages("SnowballC") # for text stemming
install.packages("wordcloud") # word-cloud generator
install.packages("RColorBrewer") # color palettes
install.packages("RColorBrewer")
library(jsonlite)
library(dashR)
library(dashCoreComponents)
library(dashHtmlComponents)
app <- Dash$new()
app$layout_set(
htmlDiv(list(
htmlH1('Hello Dash'),
htmlDiv(id='a', children="Dash: A web application framework for R."),
dccGraph(figure=list(
data=list(
list(
x=list(1, 2, 3),
y=list(4, 1, 2),
type='bar',
name='SF'
),
list(
x=list(1, 2, 3),
y=list(2, 4, 5),
type='bar',
name='MontrÃ©al'
)
),
layout=list(title='Dash Data Visualization')
),
id='b'
)
))
)
app$callback(output('a', 'children'), list(input('b', 'hoverData')),
function(hoverData) {
toJSON(hoverData)
}
)
app$run_server()
